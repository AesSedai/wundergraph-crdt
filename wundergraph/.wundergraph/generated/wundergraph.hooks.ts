// Code generated by wunderctl. DO NOT EDIT.

import type {
	AuthenticationHookRequest,
	AuthenticationResponse,
	BaseRequestContext,
	HooksConfiguration,
	WsTransportOnConnectionInitResponse,
	WunderGraphRequest,
	WunderGraphResponse,
} from "@wundergraph/sdk/server";
import {
	CrdtAuthorsResponse,
	CreateBookResponse,
	CreateCrdtResponse,
	DeleteBookResponse,
	InjectedCrdtAuthorsInput,
	InjectedCreateBookInput,
	InjectedCreateCrdtInput,
	InjectedDeleteBookInput,
	InjectedQueryCrdtInput,
	InjectedQueryGetAuthorsInput,
	InjectedQueryGetBooksInput,
	InjectedSeedAuthorsInput,
	InjectedSubscribeAuthorsInput,
	InjectedSubscribeBooksInput,
	InjectedUpdateAuthorNameInput,
	InjectedUpdateBookInput,
	InjectedUpdateCrdtInput,
	InjectedUpsertCrdtInput,
	QueryCrdtResponse,
	QueryGetAuthorsResponse,
	QueryGetBooksResponse,
	ResetAuthorsResponse,
	SeedAuthorsResponse,
	SubscribeAuthorsResponse,
	SubscribeBooksResponse,
	UpdateAuthorNameResponse,
	UpdateBookResponse,
	UpdateCrdtResponse,
	UpsertCrdtResponse,
} from "./models";
import type { InternalClient } from "./wundergraph.internal.client";
import type { User } from "./wundergraph.server";

// use SKIP to skip the hook and continue the request / response chain without modifying the request / response
export type SKIP = "skip";

// use CANCEL to skip the hook and cancel the request / response chain
// this is semantically equal to throwing an error (500)
export type CANCEL = "cancel";

export type WUNDERGRAPH_OPERATION =
	| "CrdtAuthors"
	| "CreateBook"
	| "CreateCrdt"
	| "DeleteBook"
	| "QueryCrdt"
	| "QueryGetAuthors"
	| "QueryGetBooks"
	| "ResetAuthors"
	| "SeedAuthors"
	| "SubscribeAuthors"
	| "SubscribeBooks"
	| "UpdateAuthorName"
	| "UpdateBook"
	| "UpdateCrdt"
	| "UpsertCrdt";

export type DATA_SOURCES = never;

export interface HttpTransportHookRequest extends BaseRequestContext<User, InternalClient> {
	request: WunderGraphRequest;
	operation: {
		name: WUNDERGRAPH_OPERATION;
		type: "mutation" | "query" | "subscription";
	};
}
export interface HttpTransportHookRequestWithResponse extends BaseRequestContext<User, InternalClient> {
	response: WunderGraphResponse;
	operation: {
		name: string;
		type: string;
	};
}
export interface WsTransportHookRequest extends BaseRequestContext<User, InternalClient> {
	dataSourceId: DATA_SOURCES;
	request: WunderGraphRequest;
}
export interface GlobalHooksConfig {
	httpTransport?: {
		// onRequest is called right before the request is sent to the origin
		// it can be used to modify the request
		// you can return SKIP to skip the hook and continue the request chain without modifying the request
		// you can return CANCEL to cancel the request chain and return a 500 error
		onOriginRequest?: {
			hook: (hook: HttpTransportHookRequest) => Promise<WunderGraphRequest | SKIP | CANCEL>;
			// calling the httpTransport hooks has a case, because the custom httpTransport hooks have to be called for each request
			// for this reason, you have to explicitly enable the hook for each Operation
			enableForOperations?: WUNDERGRAPH_OPERATION[];
			// enableForAllOperations will disregard the enableForOperations property and enable the hook for all operations
			enableForAllOperations?: boolean;
		};
		// onResponse is called right after the response is received from the origin
		// it can be used to modify the response
		// you can return SKIP to skip the hook and continue the response chain without modifying the response
		// you can return CANCEL to cancel the response chain and return a 500 error
		onOriginResponse?: {
			hook: (hook: HttpTransportHookRequestWithResponse) => Promise<WunderGraphResponse | SKIP | CANCEL>;
			// calling the httpTransport hooks has a case, because the custom httpTransport hooks have to be called for each request
			// for this reason, you have to explicitly enable the hook for each Operation
			enableForOperations?: WUNDERGRAPH_OPERATION[];
			// enableForAllOperations will disregard the enableForOperations property and enable the hook for all operations
			enableForAllOperations?: boolean;
		};
	};
	wsTransport?: {
		// onConnectionInit is used to populate 'connection_init' message payload with custom data
		// it can be used to authenticate the websocket connection
		onConnectionInit?: {
			hook: (hook: WsTransportHookRequest) => Promise<WsTransportOnConnectionInitResponse>;
			/**
			 * enableForDataSources will enable the hook for specific data sources.
			 * you should provide a list of data sources ids
			 * an id is the identifier of the data source in the wundergraph.config.ts file
			 * @example
			 *const chat = introspect.graphql({
			 *	id: 'chatId',
			 *	apiNamespace: 'chat',
			 *	url: 'http://localhost:8085/query',
			 *});
			 */
			enableForDataSources: DATA_SOURCES[];
		};
	};
}

export type JSONValue = string | number | boolean | JSONObject | Array<JSONValue>;

export type JSONObject = { [key: string]: JSONValue };

export interface HookRequest extends BaseRequestContext<User, InternalClient> {}

export interface HookRequestWithResponse<Response> extends HookRequest {
	response: Response;
}

export interface HookRequestWithInput<Input> extends HookRequest {
	input: Input;
}

export interface HooksConfig extends HooksConfiguration<Queries, Mutations, Subscriptions, User, InternalClient> {
	global?: GlobalHooksConfig;
	authentication?: {
		postAuthentication?: (hook: AuthenticationHookRequest<User, InternalClient>) => Promise<void>;
		mutatingPostAuthentication?: (
			hook: AuthenticationHookRequest<User, InternalClient>
		) => Promise<AuthenticationResponse<User>>;
		revalidate?: (hook: AuthenticationHookRequest<User, InternalClient>) => Promise<AuthenticationResponse<User>>;
		postLogout?: (hook: AuthenticationHookRequest<User, InternalClient>) => Promise<void>;
	};
	queries?: Queries;
	mutations?: Mutations;
	subscriptions?: Subscriptions;
}

export interface Queries {
	QueryCrdt?: {
		mockResolve?: (hook: HookRequestWithInput<InjectedQueryCrdtInput>) => Promise<QueryCrdtResponse>;
		preResolve?: (hook: HookRequestWithInput<InjectedQueryCrdtInput>) => Promise<void>;
		mutatingPreResolve?: (hook: HookRequestWithInput<InjectedQueryCrdtInput>) => Promise<InjectedQueryCrdtInput>;
		postResolve?: (
			hook: HookRequestWithInput<InjectedQueryCrdtInput> & HookRequestWithResponse<QueryCrdtResponse>
		) => Promise<void>;
		customResolve?: (hook: HookRequestWithInput<InjectedQueryCrdtInput>) => Promise<void | QueryCrdtResponse>;
		mutatingPostResolve?: (
			hook: HookRequestWithInput<InjectedQueryCrdtInput> & HookRequestWithResponse<QueryCrdtResponse>
		) => Promise<QueryCrdtResponse>;
	};
	QueryGetAuthors?: {
		mockResolve?: (hook: HookRequestWithInput<InjectedQueryGetAuthorsInput>) => Promise<QueryGetAuthorsResponse>;
		preResolve?: (hook: HookRequestWithInput<InjectedQueryGetAuthorsInput>) => Promise<void>;
		mutatingPreResolve?: (
			hook: HookRequestWithInput<InjectedQueryGetAuthorsInput>
		) => Promise<InjectedQueryGetAuthorsInput>;
		postResolve?: (
			hook: HookRequestWithInput<InjectedQueryGetAuthorsInput> & HookRequestWithResponse<QueryGetAuthorsResponse>
		) => Promise<void>;
		customResolve?: (
			hook: HookRequestWithInput<InjectedQueryGetAuthorsInput>
		) => Promise<void | QueryGetAuthorsResponse>;
		mutatingPostResolve?: (
			hook: HookRequestWithInput<InjectedQueryGetAuthorsInput> & HookRequestWithResponse<QueryGetAuthorsResponse>
		) => Promise<QueryGetAuthorsResponse>;
	};
	QueryGetBooks?: {
		mockResolve?: (hook: HookRequestWithInput<InjectedQueryGetBooksInput>) => Promise<QueryGetBooksResponse>;
		preResolve?: (hook: HookRequestWithInput<InjectedQueryGetBooksInput>) => Promise<void>;
		mutatingPreResolve?: (
			hook: HookRequestWithInput<InjectedQueryGetBooksInput>
		) => Promise<InjectedQueryGetBooksInput>;
		postResolve?: (
			hook: HookRequestWithInput<InjectedQueryGetBooksInput> & HookRequestWithResponse<QueryGetBooksResponse>
		) => Promise<void>;
		customResolve?: (hook: HookRequestWithInput<InjectedQueryGetBooksInput>) => Promise<void | QueryGetBooksResponse>;
		mutatingPostResolve?: (
			hook: HookRequestWithInput<InjectedQueryGetBooksInput> & HookRequestWithResponse<QueryGetBooksResponse>
		) => Promise<QueryGetBooksResponse>;
	};
}

export interface Mutations {
	CreateBook?: {
		mockResolve?: (hook: HookRequestWithInput<InjectedCreateBookInput>) => Promise<CreateBookResponse>;
		preResolve?: (hook: HookRequestWithInput<InjectedCreateBookInput>) => Promise<void>;
		mutatingPreResolve?: (hook: HookRequestWithInput<InjectedCreateBookInput>) => Promise<InjectedCreateBookInput>;
		postResolve?: (
			hook: HookRequestWithInput<InjectedCreateBookInput> & HookRequestWithResponse<CreateBookResponse>
		) => Promise<void>;
		customResolve?: (hook: HookRequestWithInput<InjectedCreateBookInput>) => Promise<void | CreateBookResponse>;
		mutatingPostResolve?: (
			hook: HookRequestWithInput<InjectedCreateBookInput> & HookRequestWithResponse<CreateBookResponse>
		) => Promise<CreateBookResponse>;
	};
	CreateCrdt?: {
		mockResolve?: (hook: HookRequestWithInput<InjectedCreateCrdtInput>) => Promise<CreateCrdtResponse>;
		preResolve?: (hook: HookRequestWithInput<InjectedCreateCrdtInput>) => Promise<void>;
		mutatingPreResolve?: (hook: HookRequestWithInput<InjectedCreateCrdtInput>) => Promise<InjectedCreateCrdtInput>;
		postResolve?: (
			hook: HookRequestWithInput<InjectedCreateCrdtInput> & HookRequestWithResponse<CreateCrdtResponse>
		) => Promise<void>;
		customResolve?: (hook: HookRequestWithInput<InjectedCreateCrdtInput>) => Promise<void | CreateCrdtResponse>;
		mutatingPostResolve?: (
			hook: HookRequestWithInput<InjectedCreateCrdtInput> & HookRequestWithResponse<CreateCrdtResponse>
		) => Promise<CreateCrdtResponse>;
	};
	DeleteBook?: {
		mockResolve?: (hook: HookRequestWithInput<InjectedDeleteBookInput>) => Promise<DeleteBookResponse>;
		preResolve?: (hook: HookRequestWithInput<InjectedDeleteBookInput>) => Promise<void>;
		mutatingPreResolve?: (hook: HookRequestWithInput<InjectedDeleteBookInput>) => Promise<InjectedDeleteBookInput>;
		postResolve?: (
			hook: HookRequestWithInput<InjectedDeleteBookInput> & HookRequestWithResponse<DeleteBookResponse>
		) => Promise<void>;
		customResolve?: (hook: HookRequestWithInput<InjectedDeleteBookInput>) => Promise<void | DeleteBookResponse>;
		mutatingPostResolve?: (
			hook: HookRequestWithInput<InjectedDeleteBookInput> & HookRequestWithResponse<DeleteBookResponse>
		) => Promise<DeleteBookResponse>;
	};
	ResetAuthors?: {
		mockResolve?: (hook: HookRequest) => Promise<ResetAuthorsResponse>;
		preResolve?: (hook: HookRequest) => Promise<void>;

		postResolve?: (hook: HookRequest & HookRequestWithResponse<ResetAuthorsResponse>) => Promise<void>;
		customResolve?: (hook: HookRequest) => Promise<void | ResetAuthorsResponse>;
		mutatingPostResolve?: (
			hook: HookRequest & HookRequestWithResponse<ResetAuthorsResponse>
		) => Promise<ResetAuthorsResponse>;
	};
	SeedAuthors?: {
		mockResolve?: (hook: HookRequestWithInput<InjectedSeedAuthorsInput>) => Promise<SeedAuthorsResponse>;
		preResolve?: (hook: HookRequestWithInput<InjectedSeedAuthorsInput>) => Promise<void>;
		mutatingPreResolve?: (hook: HookRequestWithInput<InjectedSeedAuthorsInput>) => Promise<InjectedSeedAuthorsInput>;
		postResolve?: (
			hook: HookRequestWithInput<InjectedSeedAuthorsInput> & HookRequestWithResponse<SeedAuthorsResponse>
		) => Promise<void>;
		customResolve?: (hook: HookRequestWithInput<InjectedSeedAuthorsInput>) => Promise<void | SeedAuthorsResponse>;
		mutatingPostResolve?: (
			hook: HookRequestWithInput<InjectedSeedAuthorsInput> & HookRequestWithResponse<SeedAuthorsResponse>
		) => Promise<SeedAuthorsResponse>;
	};
	UpdateAuthorName?: {
		mockResolve?: (hook: HookRequestWithInput<InjectedUpdateAuthorNameInput>) => Promise<UpdateAuthorNameResponse>;
		preResolve?: (hook: HookRequestWithInput<InjectedUpdateAuthorNameInput>) => Promise<void>;
		mutatingPreResolve?: (
			hook: HookRequestWithInput<InjectedUpdateAuthorNameInput>
		) => Promise<InjectedUpdateAuthorNameInput>;
		postResolve?: (
			hook: HookRequestWithInput<InjectedUpdateAuthorNameInput> & HookRequestWithResponse<UpdateAuthorNameResponse>
		) => Promise<void>;
		customResolve?: (
			hook: HookRequestWithInput<InjectedUpdateAuthorNameInput>
		) => Promise<void | UpdateAuthorNameResponse>;
		mutatingPostResolve?: (
			hook: HookRequestWithInput<InjectedUpdateAuthorNameInput> & HookRequestWithResponse<UpdateAuthorNameResponse>
		) => Promise<UpdateAuthorNameResponse>;
	};
	UpdateBook?: {
		mockResolve?: (hook: HookRequestWithInput<InjectedUpdateBookInput>) => Promise<UpdateBookResponse>;
		preResolve?: (hook: HookRequestWithInput<InjectedUpdateBookInput>) => Promise<void>;
		mutatingPreResolve?: (hook: HookRequestWithInput<InjectedUpdateBookInput>) => Promise<InjectedUpdateBookInput>;
		postResolve?: (
			hook: HookRequestWithInput<InjectedUpdateBookInput> & HookRequestWithResponse<UpdateBookResponse>
		) => Promise<void>;
		customResolve?: (hook: HookRequestWithInput<InjectedUpdateBookInput>) => Promise<void | UpdateBookResponse>;
		mutatingPostResolve?: (
			hook: HookRequestWithInput<InjectedUpdateBookInput> & HookRequestWithResponse<UpdateBookResponse>
		) => Promise<UpdateBookResponse>;
	};
	UpdateCrdt?: {
		mockResolve?: (hook: HookRequestWithInput<InjectedUpdateCrdtInput>) => Promise<UpdateCrdtResponse>;
		preResolve?: (hook: HookRequestWithInput<InjectedUpdateCrdtInput>) => Promise<void>;
		mutatingPreResolve?: (hook: HookRequestWithInput<InjectedUpdateCrdtInput>) => Promise<InjectedUpdateCrdtInput>;
		postResolve?: (
			hook: HookRequestWithInput<InjectedUpdateCrdtInput> & HookRequestWithResponse<UpdateCrdtResponse>
		) => Promise<void>;
		customResolve?: (hook: HookRequestWithInput<InjectedUpdateCrdtInput>) => Promise<void | UpdateCrdtResponse>;
		mutatingPostResolve?: (
			hook: HookRequestWithInput<InjectedUpdateCrdtInput> & HookRequestWithResponse<UpdateCrdtResponse>
		) => Promise<UpdateCrdtResponse>;
	};
	UpsertCrdt?: {
		mockResolve?: (hook: HookRequestWithInput<InjectedUpsertCrdtInput>) => Promise<UpsertCrdtResponse>;
		preResolve?: (hook: HookRequestWithInput<InjectedUpsertCrdtInput>) => Promise<void>;
		mutatingPreResolve?: (hook: HookRequestWithInput<InjectedUpsertCrdtInput>) => Promise<InjectedUpsertCrdtInput>;
		postResolve?: (
			hook: HookRequestWithInput<InjectedUpsertCrdtInput> & HookRequestWithResponse<UpsertCrdtResponse>
		) => Promise<void>;
		customResolve?: (hook: HookRequestWithInput<InjectedUpsertCrdtInput>) => Promise<void | UpsertCrdtResponse>;
		mutatingPostResolve?: (
			hook: HookRequestWithInput<InjectedUpsertCrdtInput> & HookRequestWithResponse<UpsertCrdtResponse>
		) => Promise<UpsertCrdtResponse>;
	};
}

export interface Subscriptions {
	CrdtAuthors?: {
		preResolve?: (hook: HookRequestWithInput<InjectedCrdtAuthorsInput>) => Promise<void>;
		mutatingPreResolve?: (hook: HookRequestWithInput<InjectedCrdtAuthorsInput>) => Promise<InjectedCrdtAuthorsInput>;
		postResolve?: (
			hook: HookRequestWithInput<InjectedCrdtAuthorsInput> & HookRequestWithResponse<CrdtAuthorsResponse>
		) => Promise<void>;
		mutatingPostResolve?: (
			hook: HookRequestWithInput<InjectedCrdtAuthorsInput> & HookRequestWithResponse<CrdtAuthorsResponse>
		) => Promise<CrdtAuthorsResponse>;
	};
	SubscribeAuthors?: {
		preResolve?: (hook: HookRequestWithInput<InjectedSubscribeAuthorsInput>) => Promise<void>;
		mutatingPreResolve?: (
			hook: HookRequestWithInput<InjectedSubscribeAuthorsInput>
		) => Promise<InjectedSubscribeAuthorsInput>;
		postResolve?: (
			hook: HookRequestWithInput<InjectedSubscribeAuthorsInput> & HookRequestWithResponse<SubscribeAuthorsResponse>
		) => Promise<void>;
		mutatingPostResolve?: (
			hook: HookRequestWithInput<InjectedSubscribeAuthorsInput> & HookRequestWithResponse<SubscribeAuthorsResponse>
		) => Promise<SubscribeAuthorsResponse>;
	};
	SubscribeBooks?: {
		preResolve?: (hook: HookRequestWithInput<InjectedSubscribeBooksInput>) => Promise<void>;
		mutatingPreResolve?: (
			hook: HookRequestWithInput<InjectedSubscribeBooksInput>
		) => Promise<InjectedSubscribeBooksInput>;
		postResolve?: (
			hook: HookRequestWithInput<InjectedSubscribeBooksInput> & HookRequestWithResponse<SubscribeBooksResponse>
		) => Promise<void>;
		mutatingPostResolve?: (
			hook: HookRequestWithInput<InjectedSubscribeBooksInput> & HookRequestWithResponse<SubscribeBooksResponse>
		) => Promise<SubscribeBooksResponse>;
	};
}
