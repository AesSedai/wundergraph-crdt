{
  "version": 3,
  "sources": ["../../wundergraph.server.ts", "../../lib/y-pojo.ts"],
  "sourcesContent": ["import { configureWunderGraphServer } from \"@wundergraph/sdk/server\"\r\nimport { GraphQLObjectType, GraphQLSchema, GraphQLString } from \"graphql\"\r\nimport { fromUint8Array, toUint8Array } from \"js-base64\"\r\nimport * as Y from \"yjs\"\r\n// import { CrdtAuthorsResponse } from \"./generated/models\"\r\nimport type { HooksConfig } from \"./generated/wundergraph.hooks\"\r\nimport type { InternalClient } from \"./generated/wundergraph.internal.client\"\r\nimport type { GraphQLExecutionContext } from \"./generated/wundergraph.server\"\r\nimport { syncronize } from \"./lib/y-pojo\"\r\n\r\nlet initialSync = true\r\n\r\nexport default configureWunderGraphServer<HooksConfig, InternalClient>(() => ({\r\n    hooks: {\r\n        queries: {},\r\n        mutations: {\r\n            ResetAuthors: {\r\n                postResolve: async () => {\r\n                    // set initialSync back to true\r\n                    initialSync = true\r\n                }\r\n            }\r\n        },\r\n        subscriptions: {\r\n            CrdtAuthors: {\r\n                mutatingPreResolve: async ({ input, user, log, internalClient, clientRequest }) => {\r\n                    console.log(`preResolve hook called for CrdtAuthors with ${JSON.stringify(input, null, 2)}`)\r\n                    input.limit = 150\r\n                    initialSync = true\r\n                    return input\r\n                },\r\n                mutatingPostResolve: async ({ input, user, clientRequest, log, response, internalClient }) => {\r\n                    console.log(\r\n                        `mutatingPostResolve hook called for CrdtAuthors with ${JSON.stringify(input, null, 2)}`\r\n                    )\r\n                    if (response.data == null) {\r\n                        throw new Error(\"response data cannot be null\")\r\n                    }\r\n\r\n                    const ydoc1 = new Y.Doc()\r\n                    const yDataMap = ydoc1.getMap(\"data\")\r\n\r\n                    const { data: loaded } = await internalClient.queries.QueryCrdt({ input: { client: \"first\" } })\r\n\r\n                    let hasuraCrdt = loaded?.hasura_crdt?.[0]?.state\r\n                    if (hasuraCrdt != null) {\r\n                        // const buf = bytea(hasuraCrdt)\r\n                        // hasuraCrdt = hasuraCrdt.slice(2)\r\n                        // console.log(\"hasuraCrdt\", hasuraCrdt)\r\n                        Y.applyUpdate(ydoc1, toUint8Array(hasuraCrdt))\r\n                        // console.log(\"applied update\")\r\n                    }\r\n\r\n                    let diff: Uint8Array\r\n                    let stateVector: Uint8Array\r\n\r\n                    if (initialSync) {\r\n                        initialSync = false\r\n                        stateVector = toUint8Array(input.sv)\r\n                    } else {\r\n                        stateVector = Y.encodeStateVector(ydoc1)\r\n                    }\r\n\r\n                    syncronize(yDataMap, response.data)\r\n                    diff = Y.encodeStateAsUpdate(ydoc1, stateVector)\r\n\r\n                    await internalClient.mutations.UpsertCrdt({\r\n                        input: {\r\n                            crdt: {\r\n                                client: \"first\",\r\n                                state: fromUint8Array(Y.encodeStateAsUpdate(ydoc1)),\r\n                                vector: fromUint8Array(Y.encodeStateVector(ydoc1))\r\n                            }\r\n                        }\r\n                    })\r\n\r\n                    // Y.logUpdate(diff)\r\n\r\n                    console.log(\"diff\", diff.length, fromUint8Array(diff).length, diff)\r\n                    // console.log(\"encoded state\", fromUint8Array(Y.encodeStateAsUpdate(ydoc1)))\r\n\r\n                    // mangle the return into {data: string} so we can handle it on the client\r\n                    return { data: fromUint8Array(diff) } as unknown as any\r\n                }\r\n            }\r\n        }\r\n    },\r\n    graphqlServers: [\r\n        {\r\n            apiNamespace: \"public\",\r\n            serverName: \"public\",\r\n            enableGraphQLEndpoint: true,\r\n            schema: new GraphQLSchema({\r\n                query: new GraphQLObjectType<any, GraphQLExecutionContext>({\r\n                    name: \"Query\",\r\n                    fields: {\r\n                        hello: {\r\n                            type: GraphQLString,\r\n                            resolve: (args: any, ctx: GraphQLExecutionContext) => {\r\n                                return `Hello ${ctx.wundergraph.user?.name || \"World\"}`\r\n                            }\r\n                        }\r\n                    }\r\n                }),\r\n                subscription: new GraphQLObjectType<any, GraphQLExecutionContext>({\r\n                    name: \"Subscription\",\r\n                    fields: {\r\n                        hello: {\r\n                            type: GraphQLString,\r\n                            resolve: (args: any, ctx: GraphQLExecutionContext) => {\r\n                                return `Hello ${ctx.wundergraph.user?.name || \"World\"}`\r\n                            }\r\n                        }\r\n                    }\r\n                })\r\n            })\r\n        }\r\n    ]\r\n}))\r\n", "import * as Y from \"yjs\"\n\ntype managedType = Y.Map<any> | Y.Array<any> | string | number\ntype supportedType = object | string | number\n\nexport function deepEquals(managed: managedType, target: supportedType | supportedType[]): boolean {\n    const managedType = detectManagedType(managed)\n\n    try {\n        var targetType = target.constructor.name\n    } catch (e) {\n        targetType = \"undefined\"\n    }\n\n    if (managedType == \"YArray\" && targetType == \"Array\") {\n        const targetArray = target as Array<any>\n        const managedArray = managed as Y.Array<any>\n\n        const result =\n            managedArray.length == targetArray.length &&\n            targetArray.every((t, i) => deepEquals(managedArray.get(i), targetArray[i]))\n        return result\n    } else if (managedType == \"YMap\" && targetType == \"Object\") {\n        const targetMap = target as Record<string, any>\n        const managedMap = managed as Y.Map<any>\n\n        let targetKeyCount = 0\n        for (let targetKey in targetMap) {\n            targetKeyCount++\n            if (!deepEquals(managedMap.get(targetKey), targetMap[targetKey])) {\n                return false\n            }\n        }\n        return targetKeyCount == Array.from(managedMap.keys()).length\n    } else {\n        return target === managed\n    }\n}\n\nexport function syncronize(managedObj: Y.Map<any> | Y.Array<any>, targetObj: Record<string, any> | any[]): boolean {\n    let changed = false\n\n    const managedType = detectManagedType(managedObj)\n\n    switch (managedType) {\n        case \"YArray\":\n            if (!Array.isArray(targetObj)) {\n                throw new Error(`Sync failed, ${targetObj} was not array`)\n            }\n\n            const managedArray = managedObj as Y.Array<any>\n            const targetArray = targetObj as any[]\n            const outOfRange = Symbol()\n\n            let cursor = 0\n            for (let i = 0; i < targetArray.length; i++) {\n                let match = false\n                const targetValue = targetArray[i]\n                const len = managedArray.length > targetArray.length ? managedArray.length : targetArray.length\n                for (let j = cursor; !match && j < len; j++) {\n                    const managedValue = j < managedArray.length ? managedArray.get(j) : outOfRange\n                    const targetValue = i < targetArray.length ? targetArray[i] : outOfRange\n\n                    if (deepEquals(managedValue, targetValue)) {\n                        for (let x = j - 1; x >= cursor; x--) {\n                            changed = true\n                            managedArray.delete(x)\n                        }\n                        const deletedCount = j - cursor\n                        cursor = j + 1 - deletedCount\n                        match = true\n                    }\n                }\n                if (!match) {\n                    try {\n                        var childType = targetValue.constructor.name\n                    } catch (e) {\n                        childType = \"undefined\"\n                    }\n                    const managedChild = cursor < managedArray.length ? managedArray.get(cursor) : \"undefined\"\n                    const managedType = detectManagedType(managedChild)\n\n                    // but if they're compatible types we should go deeper\n                    // there was no exact match in the list, so assume the immediately next object should be the match\n                    if (\n                        (managedType == \"YMap\" && childType == \"Object\") ||\n                        (managedType == \"YArray\" && childType == \"Array\")\n                    ) {\n                        syncronize(managedChild, targetValue)\n                    } else {\n                        managedArray.insert(cursor, [syncChild(targetValue)])\n                    }\n\n                    cursor++\n                    changed = true\n                }\n            }\n            while (managedArray.length > targetArray.length) {\n                changed = true\n                managedArray.delete(targetArray.length)\n            }\n\n            break\n        case \"YMap\":\n            if (targetObj.constructor.name !== \"Object\") {\n                throw new Error(`Sync failed, ${targetObj} was not object`)\n            }\n\n            const managedMap = managedObj as Y.Map<any>\n            const targetMap = targetObj as Record<string, any>\n\n            for (const key of managedMap.keys()) {\n                if (!(key in targetObj)) {\n                    // item's been removed from target\n                    managedMap.delete(key)\n                    changed = true\n                    continue\n                }\n                const managedChild = managedMap.get(key)\n                const targetChild = targetMap[key]\n\n                const managedType = detectManagedType(managedChild)\n\n                try {\n                    var childType = targetChild.constructor.name\n                } catch (e) {\n                    childType = \"undefined\"\n                }\n\n                if (\n                    (managedType == \"YMap\" && childType !== \"Object\") ||\n                    (managedType == \"YArray\" && childType !== \"Array\") ||\n                    (![\"YMap\", \"YArray\"].includes(managedType) && managedType !== childType)\n                ) {\n                    // this item has fundamentally changed, delete the existing record and recreate it in second pass\n                    managedMap.delete(key)\n                    changed = true\n                } else if (managedType == \"YMap\" || managedType == \"YArray\") {\n                    // they match in types, so go deeper\n                    const childChanged = syncronize(managedChild, targetChild)\n                    changed ||= childChanged\n                } else {\n                    // they are not complex types so just assign it into the map\n                    if (managedChild !== targetChild) {\n                        managedMap.set(key, targetChild)\n                        changed = true\n                    }\n                }\n            }\n\n            for (const key in targetMap) {\n                if (!managedMap.has(key)) {\n                    const child = syncChild(targetMap[key])\n\n                    managedMap.set(key, child)\n                    changed = true\n                }\n            }\n            break\n        default:\n            throw new Error(`can only iterate over Y.Map and Y.Array, got ${managedObj}`)\n    }\n    return changed\n}\n\nfunction syncChild(child: any): any {\n    try {\n        var childType = child.constructor.name\n    } catch (e) {\n        childType = \"undefined\"\n    }\n\n    if (childType == \"Array\") {\n        const arr = new Y.Array()\n\n        syncronize(arr, child)\n        return arr\n    } else if (childType == \"Object\") {\n        const map = new Y.Map()\n\n        syncronize(map, child)\n        return map\n    } else {\n        return child\n    }\n}\n\nfunction detectManagedType(managed: any): string {\n    try {\n        if (managed.length !== undefined && managed.get !== undefined) {\n            return \"YArray\"\n        } else if (managed.keys !== undefined && managed.get !== undefined) {\n            return \"YMap\"\n        } else {\n            return managed.constructor.name\n        }\n    } catch (e) {\n        return \"undefined\"\n    }\n}\n"],
  "mappings": "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",
  "names": ["Y", "targetValue", "managedType"]
}
