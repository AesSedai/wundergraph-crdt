{
  "version": 3,
  "sources": ["../../lib/pigeon/helpers.js", "../../lib/pigeon/diff.js", "../../lib/pigeon/patch.js", "../../lib/pigeon/reverse.js", "../../lib/pigeon/auto.js", "../../lib/pigeon/index.js", "../../wundergraph.server.ts", "../../lib/y-pojo/y-pojo.ts"],
  "sourcesContent": ["let _config = {\n  strict: true,\n  getObjectId: x => x.id || x._id || x.uuid || x.slug,\n  getTimestamp: Date.now,\n};\n\nfunction _configure(options) {\n  Object.assign(_config, options);\n}\n\nfunction _path(path, k, o) {\n  if (o) {\n    const id = _objId(o);\n    if (id) k = `[${id}]`;\n  }\n  return _encodePath(path, k);\n}\n\nfunction _encodeKey(key) {\n  return typeof(key) == 'string' && (key.indexOf('/') !== -1 || key.indexOf('~') !== -1) ?\n    key.replace(/~/g, '~0').replace(/\\//g, '~1') :\n    key;\n}\n\nfunction _decodeKey(key) {\n  return typeof(key) == 'string' && (key.indexOf('~1') !== -1 || key.indexOf('~0') !== -1) ?\n    key.replace(/~1/g, '/').replace(/~0/g, '~') :\n    key;\n}\n\nfunction _decodePath(path) {\n  return path.split('/').map(c => _decodeKey(c))\n}\n\nfunction _encodePath(path, k) {\n  k = _encodeKey(k);\n  return [path, k].filter(x => x != undefined).join('/').replace('//', '/');\n}\n\nfunction _typeof(x) {\n  if (Array.isArray(x)) return 'array';\n  if (x === null) return 'null';\n  return typeof x;\n}\n\nfunction _isPrimitive(x) {\n  const t = _typeof(x);\n  return t === 'number' || t === 'null' || t === 'boolean' || t == 'string';\n}\n\nfunction _clone(x) {\n  const type = _typeof(x);\n  if (type == 'array') {\n    const arr = Array(x.length);\n    for (let i = 0; i < x.length; i++) {\n      arr[i] = _clone(x[i]);\n    }\n    return arr;\n  } else if (type == 'object') {\n    if (x.toJSON) {\n      return x.toJSON();\n    } else {\n      const obj = {};\n      for (const k in x) {\n        obj[k] = _clone(x[k]);\n      }\n      return obj;\n    }\n  } else if (_isPrimitive(x)) {\n    const isNumber = typeof x == 'number';\n    if (isNumber) {\n      if (isFinite(x)) {\n        return x;\n      } else {\n        return null;\n      }\n    } else {\n      return x;\n    }\n  }\n}\n\nfunction _entangled(a, b) {\n  if (_isPrimitive(a)) {\n    return a === b;\n  } else if (_typeof(a) == 'object') {\n    return _objId(a) === _objId(b);\n  } else if (_typeof(a) == 'array') {\n    throw new Error(\"can't compare arrays of arrays\");\n  }\n}\n\nfunction _objId(x) {\n  if (_typeof(x) == 'object') {\n    const id = _config.getObjectId(x);\n    if (id != undefined) return id;\n    if (_config.strict) {\n      throw new Error(\"couldn't find id for object\", { cause: x });\n    }\n    return _hsh(_stable(x));\n  } else {\n    return null;\n  }\n}\n\nfunction _op(op, path, extra) {\n  const operation = { op, path };\n  Object.assign(operation, extra);\n  return operation;\n}\n\nfunction _stable(x) {\n  if (_typeof(x) == 'array') {\n    return `[${x.map(_stable).join(',')}]`;\n  } else if (_typeof(x) == 'object') {\n    return `{${Object.keys(x).sort().map(k =>\n      `${JSON.stringify(k)}:${_stable(x[k])}`).join(',')}}`;\n  } else {\n    return JSON.stringify(x);\n  }\n}\n\nfunction _hsh(str) {\n  return Math.abs([].reduce.call(str, (p, c, i, a) => (p << 5) - p + a.charCodeAt(i), 0));\n}\n\nfunction _crc(x) {\n  return _hsh(_stable(x));\n}\n\nmodule.exports = {\n  _path,\n  _typeof,\n  _isPrimitive,\n  _clone,\n  _entangled,\n  _objId,\n  _op,\n  _stable,\n  _crc,\n  _decodePath,\n  _config,\n  _configure,\n}\n", "const { _path, _typeof, _isPrimitive, _clone, _entangled, _objId, _op, _config } = require('./helpers');\n\n\nfunction diff(left, right) {\n\n  const type = _typeof(left);\n\n  if (type !== _typeof(right)) {\n    throw new Error(\"can't diff different types\");\n  }\n\n  if (type == 'array') {\n    return diffArray(left, right);\n  } else if (type == 'object') {\n    return diffObject(left, right);\n  } else if (_isPrimitive(left)) {\n    return diffPrimitive(left, right);\n  } else {\n    throw new Error(\"unsupported type\");\n  }\n\n}\n\nfunction diffPrimitive(l, r, path='/') {\n  if (l !== r) {\n    return [_op('replace', _path(path), { value: r,  _prev: l, })];\n  } else {\n    return [];\n  }\n}\n\nfunction diffArray(l, r, path='/') {\n\n  const lris = {};\n  const rlis = {};\n\n  const adds = [];\n\n  for (let i = 0; i < l.length; i++) {\n    for (let j = 0; j < r.length; j++) {\n      if (j in rlis) continue;\n      if (i in lris) continue;\n      if (\n        (!_config.strict && _typeof(l[i]) == 'array' && _typeof(r[j]) == 'array' && i == j) ||\n        _entangled(l[i], r[j])\n      ) {\n        lris[i] = j;\n        rlis[j] = i;\n      }\n    }\n  }\n\n  const ops = [];\n\n  for (let i = 0, j = 0; j < r.length || i < l.length;) {\n\n    if (j in r && i in l && rlis[j] == i) {\n\n      if (_typeof(r[j]) === 'object') {\n        ops.push(...diffObject(l[i], r[j], _path(path, i, r[j])));\n      }\n      j++;\n      i++;\n      continue;\n    }\n\n    if (i < l.length && !(i in lris)) {\n      ops.push(_op('remove', _path(path, i, l[i]), { _prev: l[i] }));\n      i++;\n      continue;\n    }\n\n    if (j < r.length && !(j in rlis)) {\n      adds.unshift(_op('add', _path(path, j, r[j + 1]), { value: r[j] }));\n      j++;\n      continue;\n    }\n\n    if (j < r.length && j in rlis) {\n      const from = _path(path, rlis[j], l[rlis[j]]);\n      const to = _path(path, j);\n      if (to != from) {\n        ops.push({ op: 'move', from, path: to });\n        if (_typeof(rlis[j]) == 'object') {\n          ops.push(...diffObject(l[rlis[j]], r[j], path));\n        }\n      }\n      i++;\n      j++;\n      continue;\n    }\n\n    throw new Error(`couldn't create diff`);\n  }\n\n  return ops.concat(adds);\n}\n\n\nfunction diffObject(l, r, path='/', ref) {\n\n  const ops = [];\n\n  const lkeys = Object.keys(l);\n  const llen = lkeys.length;\n  let removals = 0;\n\n  for (let i = 0; i < llen; i++){\n\n    const k = lkeys[i];\n    if (!(r.hasOwnProperty(k))) {\n      removals++;\n      ops.push({ op: 'remove', path: _path(path, k), _prev: _clone(l[k]) });\n      continue;\n    }\n\n    if (l[k] === r[k]) continue;\n\n    const type = _typeof(l[k]);\n\n    if (_isPrimitive(l[k])) {\n      ops.push(...diffPrimitive(l[k], r[k], _path(path, k), ref));\n    } else if (type !== _typeof(r[k])) {\n      ops.push({ op: 'replace', path: _path(path, k), value: _clone(r[k]), _prev: _clone(l[k]) });\n    } else if (type === 'array') {\n      ops.push(...diffArray(l[k], r[k], _path(path, k)));\n    } else if (type === 'object') {\n      ops.push(...diffObject(l[k], r[k], _path(path, k), ref));\n    }\n  }\n\n  const rkeys = Object.keys(r);\n  const rlen = rkeys.length;\n\n  if (rlen > llen - removals) {\n    for (let i = 0; i < rlen; i++) {\n      const k = rkeys[i];\n      if (!(l.hasOwnProperty(k))) {\n        ops.push({ op: 'add', path: _path(path, k), value: _clone(r[k]) });\n      }\n    }\n  }\n\n  return ops\n}\n\n\nmodule.exports = diff;\n", "const { _typeof, _clone, _objId, _decodePath } = require('./helpers');\n\n\nfunction patch(data, changes) {\n\n  changes = _clone(changes);\n  const conflicts = [];\n  let stash = null;\n\n  CHANGE:\n  for (const [ci, change] of changes.entries()) {\n\n    const components = _decodePath(change.path);\n    const root = components.shift();\n    let tip = components.pop();\n\n    let head = data;\n\n    for (const c of components) {\n      if (!head) {\n        conflicts.push(change);\n        continue CHANGE;\n      }\n      const key = _key(c);\n      if (key) {\n        head = head.find(i => _objId(i) == key);\n      } else {\n        head = head[c];\n      }\n    }\n\n    const key = _key(tip);\n    if (key) {\n      const idx = head.findIndex(i => _objId(i) == key);\n      if (~idx) {\n        tip = idx;\n      } else {\n        conflicts.push(change);\n      }\n    }\n\n    const type = _typeof(head);\n\n    if (change.op == 'replace') {\n      head[tip] = _clone(change.value);\n    } else if (change.op == 'move') {\n      stash = {};\n      const ops = [\n        { op: 'remove', path: change.from },\n        { op: 'add', path: change.path, value: stash }\n      ];\n      changes.splice(ci + 1, 0, ...ops);\n    } else if (change.op == 'remove') {\n      if (type == 'object') {\n        stash && (stash.value = _clone(head[tip]));\n        delete head[tip];\n      } else if (type == 'array') {\n        const value = head.splice(tip, 1);\n        stash && ([ stash.value ] = value);\n      }\n    } else if (change.op == 'add') {\n      if (type == 'object') {\n        head[tip] = _clone(change.value);\n      } else if (type == 'array') {\n        if (stash && change.value === stash) {\n          head.splice(tip, 0, stash.value);\n          stash = null;\n        } else {\n          head.splice(tip, 0, _clone(change.value));\n        }\n      }\n    }\n  }\n  return data;\n}\n\n\nfunction _key(c) {\n  if (c === undefined) return;\n  const m = c.match(/^\\[(.+)\\]$/);\n  if (m) return m[1];\n}\n\nmodule.exports = patch;\n", "const { _clone, _objId } = require('./helpers');\n\nfunction reverse(changes) {\n\n  const reversed = _clone(changes).reverse();\n\n  for (const change of reversed) {\n\n    if (change.op == 'add') {\n      change.op = 'remove';\n      const id = _objId(change.value);\n      if (id) {\n        change._index = change.path.split('/').pop();\n        change.path = change.path.replace(/\\d+$/, `[${id}]`);\n      }\n\n    } else if (change.op == 'remove') {\n      change.op = 'add';\n    }\n\n    if ('_prev' in change) {\n      var _prev = change._prev;\n    }\n\n    if ('value' in change) {\n      var _value = change.value;\n    }\n\n    if (_prev === undefined) {\n      delete change.value;\n    } else {\n      change.value = _prev;\n    }\n\n    if (_value === undefined) {\n      delete change._prev;\n    } else {\n      change._prev = _value;\n    }\n\n  }\n\n  return reversed;\n\n}\n\nmodule.exports = reverse;\n", "const assert = require('assert');\nconst diff = require('./diff');\nconst patch = require('./patch');\nconst reverse = require('./reverse');\nconst { _clone, _crc, _configure, _config } = require('./helpers');\n\nlet HISTORY_LENGTH = 1000;\n\nconst meta = new WeakMap();\nconst _cid = _id();\n\nclass AutoPigeon {\n\n  constructor() {\n    meta.set(this, {\n      history: [],\n      stash: [],\n      warning: null,\n      gids: {},\n    });\n  }\n\n  static from(data, cid=_cid) {\n    let doc = new AutoPigeon();\n    meta.get(doc).cid = cid;\n    doc = AutoPigeon.change(doc, doc => Object.assign(doc, data));\n    return doc;\n  }\n\n  static _forge(data, cid=_cid) {\n    let doc = new AutoPigeon();\n    meta.get(doc).cid = cid;\n    Object.assign(doc, _clone(data));\n    return doc;\n  }\n\n  static alias(doc) {\n    let alias = new AutoPigeon();\n    meta.set(alias, meta.get(doc));\n    Object.assign(alias, doc);\n    return alias;\n  }\n\n  static init() {\n    return AutoPigeon.from({});\n  }\n\n  static clone(doc, historyLength=HISTORY_LENGTH) {\n    const clone = AutoPigeon._forge(doc);\n    meta.get(clone).history = meta.get(doc).history;\n    meta.get(clone).gids = _clone(meta.get(doc).gids);\n    AutoPigeon.pruneHistory(meta.get(clone), historyLength)\n    return clone;\n  }\n\n  static pruneHistory(meta, historyLength) {\n    const docHistoryLength = meta.history.length;\n    if (docHistoryLength > historyLength) {\n      const prunedHistory = meta.history.slice(0, docHistoryLength - historyLength);\n      for (const item of prunedHistory) {\n        delete meta.gids[item.gid];\n      }\n    }\n    meta.history = meta.history.slice(-historyLength);\n  }\n\n  static getChanges(left, right) {\n    const _diff = diff(left, right);\n    const changes = {\n      diff: _diff,\n      cid: meta.get(left).cid,\n      ts: _config.getTimestamp(),\n      seq: _seq(),\n      gid: _id(),\n    }\n    return changes;\n  }\n\n  static rewindChanges(doc, ts, cid) {\n\n    const { history } = meta.get(doc);\n\n    while (true) {\n      if (history.length <= 1) break;\n      const change = history[history.length - 1];\n      if (change.ts > ts || (change.ts == ts && change.cid > cid)) {\n        const c = meta.get(doc).history.pop();\n        patch(doc, reverse(c.diff));\n        delete meta.get(doc).gids[c.gid];\n        meta.get(doc).stash.push(c);\n        continue;\n      }\n      break;\n    }\n  }\n\n  static fastForwardChanges(doc) {\n    const { stash, history } = meta.get(doc);\n    let change;\n    while (change = stash.pop()) {\n      patch(doc, change.diff);\n      meta.get(doc).gids[change.gid] = 1;\n      history.push(change);\n    }\n  }\n\n  static applyChangesInPlace(doc, changes) {\n    return AutoPigeon.applyChanges(doc, changes, true);\n  }\n\n  static applyChanges(doc, changes, inplace) {\n    meta.get(doc).warning = null;\n    const newDoc = inplace ? doc : AutoPigeon.clone(doc);\n    if (meta.get(doc).gids[changes.gid]) {\n      return newDoc;\n    }\n    try {\n      AutoPigeon.rewindChanges(newDoc, changes.ts, changes.cid);\n    } catch (e) {\n      meta.get(newDoc).warning = 'rewind failed: ' + e;\n    }\n    try {\n      patch(newDoc, changes.diff);\n      meta.get(newDoc).gids[changes.gid] = 1;\n    } catch (e) {\n      meta.get(newDoc).warning = 'patch failed: ' + e;\n    }\n    try {\n      AutoPigeon.fastForwardChanges(newDoc);\n    } catch (e) {\n      meta.get(newDoc).warning = 'forward failed: ' + e;\n    }\n    const history = meta.get(newDoc).history;\n    let idx = history.length;\n    while (idx > 1 && history[idx - 1].ts > changes.ts) idx--;\n    history.splice(idx, 0, changes);\n    return newDoc;\n  }\n\n  static change(doc, fn) {\n\n    assert(doc instanceof AutoPigeon);\n    assert(fn instanceof Function);\n\n    const tmp = _clone(doc);\n    fn(tmp);\n    const changes = AutoPigeon.getChanges(doc, tmp);\n    return AutoPigeon.applyChanges(doc, changes);\n  }\n\n  static getHistory(doc) {\n    return meta.get(doc).history;\n  }\n\n  static merge(doc1, doc2) {\n    let doc = AutoPigeon.from({});\n    const history1 = AutoPigeon.getHistory(doc1);\n    const history2 = AutoPigeon.getHistory(doc2);\n    const changes = [];\n    while (history1.length || history2.length) {\n      if (!history2.length) {\n        changes.push(history1.shift());\n\n      } else if (!history1.length) {\n        changes.push(history2.shift());\n\n      } else if (history1[0].gid === history2[0].gid) {\n        changes.push(history1.shift() && history2.shift());\n\n      } else if (history1[0].ts < history2[0].ts) {\n        changes.push(history1.shift());\n\n      } else if (history1[0].ts == history2[0].ts) {\n\n        if (history1[0].seq < history2[0].seq) {\n          changes.push(history1.shift());\n        } else {\n          changes.push(history2.shift());\n        }\n\n      } else {\n        changes.push(history2.shift());\n      }\n    }\n\n    for (const c of changes) {\n      doc = AutoPigeon.applyChanges(doc, c);\n    }\n    return doc;\n  }\n\n  static getWarning(doc) {\n    return meta.get(doc).warning;\n  }\n\n  static getMissingDeps(doc) {\n    return false;\n  }\n\n  static setHistoryLength(len) {\n    HISTORY_LENGTH = len;\n  }\n\n  static setTimestamp(fn) {\n    _config.getTimestamp = fn;\n  }\n\n  static crc(doc) {\n    return _crc(doc);\n  }\n\n  static load(str, historyLength=HISTORY_LENGTH) {\n    const { meta: _meta, data } = JSON.parse(str);\n    AutoPigeon.pruneHistory(_meta, historyLength);\n    const doc = AutoPigeon.from(data);\n    Object.assign(meta.get(doc), _meta);\n    return doc;\n  }\n\n  static save(doc) {\n    const { cid, ..._meta } = meta.get(doc);\n    return JSON.stringify({\n      meta: _meta,\n      data: doc,\n    });\n  }\n\n  static configure(options) {\n    _configure(options);\n  }\n}\n\nfunction _id() {\n  return Math.random().toString(36).substring(2);\n}\n\nlet seq = 0;\nfunction _seq() {\n  return seq++;\n}\n\nmodule.exports = AutoPigeon;\n", "const diff = require('./diff');\nconst patch = require('./patch');\nconst reverse = require('./reverse');\nconst auto = require('./auto');\n\nfunction configure(options) {\n  helpers._configure(options);\n}\n\nmodule.exports = Object.assign(auto, { auto, diff, patch, reverse });\n", "import { configureWunderGraphServer } from \"@wundergraph/sdk/server\"\r\nimport { GraphQLObjectType, GraphQLSchema, GraphQLString } from \"graphql\"\r\nimport { fromUint8Array, toUint8Array } from \"js-base64\"\r\nimport * as Y from \"yjs\"\r\n// import { CrdtAuthorsResponse } from \"./generated/models\"\r\nimport type { HooksConfig } from \"./generated/wundergraph.hooks\"\r\nimport type { InternalClient } from \"./generated/wundergraph.internal.client\"\r\nimport type { GraphQLExecutionContext } from \"./generated/wundergraph.server\"\r\nimport { syncronize } from \"./lib/y-pojo/y-pojo\"\r\nconst { diff: pDiff } = require(\"./lib/pigeon\")\r\n\r\nconst docMap = new Map<string, Y.Doc>()\r\nconst roomName = \"authors\"\r\n\r\nexport default configureWunderGraphServer<HooksConfig, InternalClient>(() => ({\r\n    hooks: {\r\n        queries: {},\r\n        mutations: {\r\n            ResetAuthors: {\r\n                postResolve: async () => {\r\n                    // set initialSync back to true\r\n                    // initialSync = true\r\n                }\r\n            }\r\n        },\r\n        subscriptions: {\r\n            CrdtAuthors: {\r\n                mutatingPreResolve: async ({ input, user, log, internalClient, clientRequest }) => {\r\n                    console.log(`preResolve hook called for CrdtAuthors with ${JSON.stringify(input, null, 2)}`)\r\n\r\n                    let { data } = await internalClient.queries.QueryCrdt({ input: { room: roomName } })\r\n                    let response = data?.hasura_crdt?.[0]\r\n\r\n                    // populate docMap if required\r\n                    if (!docMap.has(roomName)) {\r\n                        let ydoc1: Y.Doc\r\n\r\n                        if (response == null) {\r\n                            // initialize new document\r\n                            ydoc1 = new Y.Doc()\r\n                            const ymap1 = ydoc1.getMap(\"data\")\r\n                            const { data } = await internalClient.mutations.CreateCrdt({\r\n                                input: {\r\n                                    crdt: {\r\n                                        room: roomName,\r\n                                        client: ydoc1.clientID.toString(),\r\n                                        guid: ydoc1.guid,\r\n                                        state: fromUint8Array(Y.encodeStateAsUpdate(ydoc1)),\r\n                                        vector: fromUint8Array(Y.encodeStateVector(ydoc1))\r\n                                    }\r\n                                }\r\n                            })\r\n                            const result = data?.hasura_insert_crdt_one\r\n                            if (result != null) {\r\n                                response = result\r\n                            }\r\n                        } else {\r\n                            // hydrate document\r\n                            ydoc1 = new Y.Doc({ guid: response.guid })\r\n                            ydoc1.clientID = parseInt(response.client)\r\n                            const ymap1 = ydoc1.getMap(\"data\")\r\n                            Y.applyUpdate(ydoc1, toUint8Array(response.state))\r\n                            ydoc1.clientID = parseInt(response.client)\r\n                        }\r\n\r\n                        docMap.set(roomName, ydoc1)\r\n\r\n                        ydoc1.on(\"update\", (update, origin, doc, transaction) => {\r\n                            // console.log(\"received updated for doc from origin\", origin, \"update\", update)\r\n                            // Y.logUpdate(update)\r\n                        })\r\n                    }\r\n\r\n                    if (response != null) {\r\n                        // populate client if required\r\n                        const clientResponse = await internalClient.mutations.UpsertClient({\r\n                            input: {\r\n                                client: {\r\n                                    crdt_id: response.id,\r\n                                    client: input.clientId,\r\n                                    guid: input.guid,\r\n                                    vector: input.sv\r\n                                }\r\n                            }\r\n                        })\r\n                    }\r\n\r\n                    return input\r\n                },\r\n                mutatingPostResolve: async ({ input, user, clientRequest, log, response, internalClient }) => {\r\n                    console.log(\r\n                        `mutatingPostResolve hook called for CrdtAuthors with ${JSON.stringify(input, null, 2)}`\r\n                    )\r\n                    if (response.data == null) {\r\n                        throw new Error(\"response data cannot be null\")\r\n                    }\r\n\r\n                    const ydoc1 = docMap.get(roomName)\r\n                    if (ydoc1 == null) {\r\n                        throw new Error(\"mutatingPostResolve: ydoc1 should be in the docMap\")\r\n                    }\r\n                    const yDataMap = ydoc1.getMap(\"data\")\r\n\r\n                    console.log(\"mutatingPostResolve: querying client\")\r\n                    const qResponse = await internalClient.queries.QueryClient({\r\n                        input: { client: input.clientId, room: roomName }\r\n                    })\r\n                    console.log(\"qResponse\", qResponse)\r\n\r\n                    const client = qResponse?.data?.hasura_clients[0]\r\n                    console.log(\"mutatingPostResolve client\", client)\r\n                    if (client == null) {\r\n                        throw new Error(\"client cannot be null\")\r\n                    }\r\n\r\n                    let diff: Uint8Array\r\n\r\n                    const pDiffStart = process.hrtime()\r\n                    const pDiffContent = pDiff(yDataMap.toJSON(), response.data)\r\n                    const pDiffEnd = process.hrtime(pDiffStart)\r\n                    console.log(\"pDiff time\",  pDiffEnd[1] / 1000000, \"changes\", JSON.stringify(pDiffContent, null, 2))\r\n                    console.log(\"synchronizing from vector\", client.vector)\r\n\r\n                    const syncDiffStart = process.hrtime()\r\n                    ydoc1.transact(() => {\r\n                        syncronize(yDataMap, response!.data!)\r\n                    })\r\n                    const syncDiffEnd = process.hrtime(syncDiffStart)\r\n                    diff = Y.encodeStateAsUpdate(ydoc1, toUint8Array(client.vector))\r\n                    console.log(\"syncrhonized, got diff in\", syncDiffEnd[1] / 1000000, \"upserting CRDT result\", ydoc1.clientID.toString())\r\n\r\n                    const crdtResponse = await internalClient.mutations.UpsertCrdt({\r\n                        input: {\r\n                            client: ydoc1.clientID.toString(),\r\n                            crdt: {\r\n                                state: fromUint8Array(Y.encodeStateAsUpdate(ydoc1)),\r\n                                vector: fromUint8Array(Y.encodeStateVector(ydoc1))\r\n                            }\r\n                        }\r\n                    })\r\n\r\n                    // console.log(\"mutatingPostResolve success, crdtResponse\", crdtResponse)\r\n\r\n                    // const diffUpdate = Y.diffUpdate(diff, toUint8Array(client.vector))\r\n                    // console.log(\"diffUpdate\", fromUint8Array(diffUpdate))\r\n                    // const esvDiff = Y.encodeStateVectorFromUpdate(diffUpdate)\r\n                    // console.log(\"diffUpdate sv\", fromUint8Array(esvDiff))\r\n\r\n                    // console.log(\"mutatingPostResolve upserting client\")\r\n                    const clientResponse = await internalClient.mutations.UpsertClient({\r\n                        input: {\r\n                            client: {\r\n                                client: input.clientId,\r\n                                guid: input.guid,\r\n                                vector: fromUint8Array(Y.encodeStateVector(ydoc1)) // fromUint8Array(esvDiff) // fromUint8Array(Y.encodeStateVectorFromUpdate(diff))\r\n                            }\r\n                        }\r\n                    })\r\n                    // console.log(\"mutatingPostResolve client upsert response\", clientResponse)\r\n\r\n                    // console.log(\"diff\", diff.length, fromUint8Array(diff).length, diff)\r\n                    // Y.logUpdate(diff)\r\n                    // console.log(\"encoded state\", fromUint8Array(Y.encodeStateAsUpdate(ydoc1)))\r\n\r\n                    console.log(\"mutatingPostResolve returning data\")\r\n                    // mangle the return into {data: string} so we can handle it on the client\r\n                    return { data: fromUint8Array(diff) } as unknown as any\r\n                }\r\n            }\r\n        }\r\n    },\r\n    graphqlServers: [\r\n        {\r\n            apiNamespace: \"public\",\r\n            serverName: \"public\",\r\n            enableGraphQLEndpoint: true,\r\n            schema: new GraphQLSchema({\r\n                query: new GraphQLObjectType<any, GraphQLExecutionContext>({\r\n                    name: \"Query\",\r\n                    fields: {\r\n                        hello: {\r\n                            type: GraphQLString,\r\n                            resolve: (args: any, ctx: GraphQLExecutionContext) => {\r\n                                return `Hello ${ctx.wundergraph.user?.name || \"World\"}`\r\n                            }\r\n                        }\r\n                    }\r\n                }),\r\n                subscription: new GraphQLObjectType<any, GraphQLExecutionContext>({\r\n                    name: \"Subscription\",\r\n                    fields: {\r\n                        hello: {\r\n                            type: GraphQLString,\r\n                            resolve: (args: any, ctx: GraphQLExecutionContext) => {\r\n                                return `Hello ${ctx.wundergraph.user?.name || \"World\"}`\r\n                            }\r\n                        }\r\n                    }\r\n                })\r\n            })\r\n        }\r\n    ]\r\n}))\r\n", "import * as Y from \"yjs\"\n\ntype managedType = Y.Map<any> | Y.Array<any> | string | number\ntype supportedType = object | string | number\n\nexport function deepEquals(managed: managedType, target: supportedType | supportedType[]): boolean {\n    const managedType = detectManagedType(managed)\n\n    try {\n        var targetType = target.constructor.name\n    } catch (e) {\n        targetType = \"undefined\"\n    }\n\n    if (managedType == \"YArray\" && targetType == \"Array\") {\n        const targetArray = target as Array<any>\n        const managedArray = managed as Y.Array<any>\n\n        const result =\n            managedArray.length == targetArray.length &&\n            targetArray.every((t, i) => deepEquals(managedArray.get(i), targetArray[i]))\n        return result\n    } else if (managedType == \"YMap\" && targetType == \"Object\") {\n        const targetMap = target as Record<string, any>\n        const managedMap = managed as Y.Map<any>\n\n        let targetKeyCount = 0\n        for (let targetKey in targetMap) {\n            targetKeyCount++\n            if (!deepEquals(managedMap.get(targetKey), targetMap[targetKey])) {\n                return false\n            }\n        }\n        return targetKeyCount == Array.from(managedMap.keys()).length\n    } else {\n        return target === managed\n    }\n}\n\nexport function syncronize(managedObj: Y.Map<any> | Y.Array<any>, targetObj: Record<string, any> | any[]): boolean {\n    let changed = false\n\n    const managedType = detectManagedType(managedObj)\n\n    switch (managedType) {\n        case \"YArray\":\n            if (!Array.isArray(targetObj)) {\n                throw new Error(`Sync failed, ${targetObj} was not array`)\n            }\n\n            const managedArray = managedObj as Y.Array<any>\n            const targetArray = targetObj as any[]\n            const outOfRange = Symbol()\n\n            let cursor = 0\n            for (let i = 0; i < targetArray.length; i++) {\n                let match = false\n                const targetValue = targetArray[i]\n                const len = managedArray.length > targetArray.length ? managedArray.length : targetArray.length\n                for (let j = cursor; !match && j < len; j++) {\n                    const managedValue = j < managedArray.length ? managedArray.get(j) : outOfRange\n                    const targetValue = i < targetArray.length ? targetArray[i] : outOfRange\n\n                    if (deepEquals(managedValue, targetValue)) {\n                        for (let x = j - 1; x >= cursor; x--) {\n                            changed = true\n                            managedArray.delete(x)\n                        }\n                        const deletedCount = j - cursor\n                        cursor = j + 1 - deletedCount\n                        match = true\n                    }\n                }\n                if (!match) {\n                    try {\n                        var childType = targetValue.constructor.name\n                    } catch (e) {\n                        childType = \"undefined\"\n                    }\n                    const managedChild = cursor < managedArray.length ? managedArray.get(cursor) : \"undefined\"\n                    const managedType = detectManagedType(managedChild)\n\n                    // but if they're compatible types we should go deeper\n                    // there was no exact match in the list, so assume the immediately next object should be the match\n                    if (\n                        (managedType == \"YMap\" && childType == \"Object\") ||\n                        (managedType == \"YArray\" && childType == \"Array\")\n                    ) {\n                        syncronize(managedChild, targetValue)\n                    } else {\n                        managedArray.insert(cursor, [syncChild(targetValue)])\n                    }\n\n                    cursor++\n                    changed = true\n                }\n            }\n            while (managedArray.length > targetArray.length) {\n                changed = true\n                managedArray.delete(targetArray.length)\n            }\n\n            break\n        case \"YMap\":\n            if (targetObj.constructor.name !== \"Object\") {\n                throw new Error(`Sync failed, ${targetObj} was not object`)\n            }\n\n            const managedMap = managedObj as Y.Map<any>\n            const targetMap = targetObj as Record<string, any>\n\n            for (const key of managedMap.keys()) {\n                if (!(key in targetObj)) {\n                    // item's been removed from target\n                    managedMap.delete(key)\n                    changed = true\n                    continue\n                }\n                const managedChild = managedMap.get(key)\n                const targetChild = targetMap[key]\n\n                const managedType = detectManagedType(managedChild)\n\n                try {\n                    var childType = targetChild.constructor.name\n                } catch (e) {\n                    childType = \"undefined\"\n                }\n\n                if (\n                    (managedType == \"YMap\" && childType !== \"Object\") ||\n                    (managedType == \"YArray\" && childType !== \"Array\") ||\n                    (![\"YMap\", \"YArray\"].includes(managedType) && managedType !== childType)\n                ) {\n                    // this item has fundamentally changed, delete the existing record and recreate it in second pass\n                    managedMap.delete(key)\n                    changed = true\n                } else if (managedType == \"YMap\" || managedType == \"YArray\") {\n                    // they match in types, so go deeper\n                    const childChanged = syncronize(managedChild, targetChild)\n                    changed ||= childChanged\n                } else {\n                    // they are not complex types so just assign it into the map\n                    if (managedChild !== targetChild) {\n                        managedMap.set(key, targetChild)\n                        changed = true\n                    }\n                }\n            }\n\n            for (const key in targetMap) {\n                if (!managedMap.has(key)) {\n                    const child = syncChild(targetMap[key])\n\n                    managedMap.set(key, child)\n                    changed = true\n                }\n            }\n            break\n        default:\n            throw new Error(`can only iterate over Y.Map and Y.Array, got ${managedObj}`)\n    }\n    return changed\n}\n\nfunction syncChild(child: any): any {\n    try {\n        var childType = child.constructor.name\n    } catch (e) {\n        childType = \"undefined\"\n    }\n\n    if (childType == \"Array\") {\n        const arr = new Y.Array()\n\n        syncronize(arr, child)\n        return arr\n    } else if (childType == \"Object\") {\n        const map = new Y.Map()\n\n        syncronize(map, child)\n        return map\n    } else {\n        return child\n    }\n}\n\nfunction detectManagedType(managed: any): string {\n    try {\n        if (managed.length !== undefined && managed.get !== undefined) {\n            return \"YArray\"\n        } else if (managed.keys !== undefined && managed.get !== undefined) {\n            return \"YMap\"\n        } else {\n            return managed.constructor.name\n        }\n    } catch (e) {\n        return \"undefined\"\n    }\n}\n"],
  "mappings": "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",
  "names": ["module", "module", "module", "key", "module", "module", "doc", "meta", "module", "Y", "targetValue", "managedType", "data"]
}
